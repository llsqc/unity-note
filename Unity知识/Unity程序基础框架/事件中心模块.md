### 主要作用和原理
解耦程序模块
降低程序耦合度
它可以降低游戏中不同模块的耦合度
不需要直接引用或依赖于彼此的具体实现
![[事件中心的基本原理.png]]

事件中心的基本原理
通过一个中心化的机制
使得多个系统、模块、对象之间可以进行松耦合的通信
我们只需要利用字典和委托相关的知识点
再结合观察者设计模式的基本原理便可以制作出事件中心模块

**观察者设计模式**：其主要原理是定义了一种一对多的依赖关系，使得当一个对象的
状态发生变化时，所有依赖于它的对象都能够得到通知并自动更新

### 实现事件中心模块
1. 创建EventCenter继承 不继承MonoBehaviour的单例模式基类
2. 声明管理事件用容器
3. 实现关键方法
	 触发(分发)事件 方法
	 添加事件监听者 方法
	 移除事件监听者 方法
	 清除所有事件监听者 方法

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class EventCenter : BaseManager<EventCenter>
{
    private Dictionary<string, UnityAction> _eventDict = new Dictionary<string, UnityAction>();

    private EventCenter()
    {
    }

    /// <summary>
    /// 触发事件
    /// </summary>
    /// <param name="eventName">事件名</param>
    public void EventTrigger(string eventName)
    {
        if (_eventDict.ContainsKey(eventName))
        {
            _eventDict[eventName]?.Invoke();
        }
    }

    /// <summary>
    /// 添加事件监听
    /// </summary>
    /// <param name="eventName">事件名</param>
    /// <param name="action">事件回调</param>
    public void AddEventListener(string eventName, UnityAction action)
    {
        _eventDict.TryAdd(eventName, null);
        _eventDict[eventName] += action;
    }

    /// <summary>
    /// 移除事件监听
    /// </summary>
    /// <param name="eventName">事件名</param>
    /// <param name="action">事件回调</param>
    public void RemoveEventListener(string eventName, UnityAction action)
    {
        if (_eventDict.ContainsKey(eventName))
            _eventDict[eventName] -= action;
    }

    /// <summary>
    /// 清空所有事件监听
    /// </summary>
    public void Clear()
    {
        _eventDict.Clear();
    }

    /// <summary>
    /// 清空指定事件监听
    /// </summary>
    /// <param name="eventName">事件名</param>
    public void Clear(string eventName)
    {
        _eventDict.Remove(eventName);
    }
}
```

### 模块优化
#### 传递参数
我们目前触发事件，是通过执行委托中存储的函数来执行各系统对应的逻辑
那么需要传递参数，我们很自然的联想到应该从委托入手

但是参数的类型可能有多种多样，我们可以采用万物之父 **object** 利用里式替换原则
父类容器装载子类对象的方式来传递参数

**存在的问题**
使用object进行参数传递，当传递值类型数据时，会存在装箱拆箱，增加性能开销

#### 参数类型自定义
制作思路：
想让传递的参数类型可变，并且想传什么就传什么
我们可以很自然的联想到使用泛型来制作该功能

但是我们需要解决以下关键问题：
字典容器中的 泛型委托 如何提前定好类型
解决方案：
里式替换原则（父类装子类）

#### 事件名优化
目前我们通过 字符串 作为事件名来区分各事件
明显的缺点：
若触发或监听时，事件名 字符串 拼写错误会导致
无法正确监听或触发事件

制作思路和具体实现
将事件名使用枚举进行统一管理