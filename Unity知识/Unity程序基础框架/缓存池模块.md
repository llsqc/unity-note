缓存池（对象池）的主要作用
通过重复利用已经创建的对象，避免频繁的创建和销毁
从而减少系统的内存分配和垃圾回收带来的开销

缓存池（对象池）的基本原理
用一个“柜子”中的“各种抽屉”来装“东西”
用时去拿（没有就创造，存在就获取）
不用就还（将“东西”分门别类的放入“抽屉”中）

### 实现缓存池(对象池)模块
1. 创建PoolMgr继承 不继承MonoBehaviour的单例模式基类
2. 声明柜子(Dictionary)和抽屉(List、Stack、Queue等)容器
3. 拿东西方法
	1. 有抽屉并且抽屉里有东西 直接获取
	2. 没有抽屉或者抽屉里没东西 创造
4. 放东西方法
	1. 有抽屉，直接放
	2. 没抽屉，创建抽屉，再放
5. 清空柜子方法
 我们在切场景时，对象都会被移除，这时应该清空柜子
 否则会出现内存泄漏，并且下次取东西会出问题

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PoolMgr : BaseManager<PoolMgr>
{
    private Dictionary<string, Stack<GameObject>> poolDic = new Dictionary<string, Stack<GameObject>>();
    private PoolMgr() { }

    /// <summary>
    /// 从缓存池取game object
    /// </summary>
    /// <param name="name"></param>
    /// <returns></returns>
    public GameObject GetObject(string name)
    {
        GameObject obj = null;
        if (poolDic.ContainsKey(name) && poolDic[name].Count > 0)
        {
            obj = poolDic[name].Pop();
            obj.SetActive(true);
        }
        else
        {
            obj = Object.Instantiate(Resources.Load<GameObject>(name));
            obj.name = name;
        }

        return obj;
    }

    /// <summary>
    /// 缓存game object
    /// </summary>
    /// <param name="name"></param>
    /// <param name="obj"></param>
    public void PushObject(GameObject obj)
    {
        obj.SetActive(false);
        if (!poolDic.ContainsKey(obj.name))
            poolDic.Add(obj.name, new Stack<GameObject>());
        poolDic[obj.name].Push(obj);
    }

    /// <summary>
    /// 清空缓存池
    /// </summary>
    public void ClearPool()
    {
        poolDic.Clear();
    }
}
```

### 缓存池优化
#### 窗口布局优化
现在直接失活对象，当之后项目做大了，抽屉多了，对象多了
游戏中成百上千个对象，在开发测试时不方便从Hierarchy窗口中查看对象获取信息
因此我们希望能优化一下Hierarchy窗口中的布局
将对象和抽屉的关系可视化

#### 制作思路和具体实现
制作思路：
1. 柜子管理自己的柜子根物体
2. 抽屉管理自己的抽屉根物体
3. 失活时建立父子关系，激活活时断开父子关系

具体实现:
1. 先实现将所有对象放入柜子根物体中
2. 再实现将对象放入对应的抽屉根物体中
 用面向对象的思想将抽屉相关数据行为封装起来

将其变为可控制开启的功能，可以避免在真机运行时由于父子关系的频繁变换带来一些额外的性能开销

#### 对象上限优化
目前我们制作的缓存池模块
理论上来说，当动态创建的对象长时间不放回抽屉
每次从缓存池中动态获取对象时，会不停的新建对象
那么也就是对象的数量是没有上限的
场景上的某种对象可以存在n个

而对象上限优化指的就是
我们希望控制对象数量有上限
对于不重要的资源我们没必要让其无限加量
而是将“使用最久”的资源直接抢来用

主要目的：
更加彻底的复用资源
对对象的数量上限加以限制
可以优化内存空间，甚至优化性能（减少数量上限，可以减小渲染压力）

#### 制作思路和具体实现
制作思路：
1. 在抽屉里声明一个容器用来记录正在使用的资源
2. 每次获取对象时，传入一个抽屉最大容量值（可以给一个默认值）
3. 从缓存池中获取对象时就需要创建抽屉，用于记录当前使用着的对象
4. 每次取对象时应该分情况考虑
	 情况1：没有抽屉时
	 情况2：有抽屉，并且抽屉里有没用的对象或者使用中对象超过上限时
	 情况3：有抽屉，但是抽屉里没有对象，使用中对象也没有超过上限时
5. 每次放回对象时
	 由于记录了正在使用的资源，因此每次放入抽屉时还需要从记录容器中移除对象