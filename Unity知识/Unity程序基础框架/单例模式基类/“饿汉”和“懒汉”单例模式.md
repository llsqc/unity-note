### “懒汉”单例模式
主要特点是在属性或者方法中进行判空后再实例化。
![[“懒汉”单例模式.png]]

这个**懒**字体现在：**这种单例模式只会在第一次使用时才创建事例，而不是应用程序启动时就创建。**
它的好处也在于此，因为**只有当我们代码中需要用到某个单例模式对象时才会去实例化分配内存**。
在商业项目中，游戏系统是非常多的，内存开销也是较大的，懒汉模式的**延迟实例化特点**可以帮助我们在一定程度上缓解内存压力。

### “饿汉”单例模式
“饿汉”单例模式的传统写法如同下图
![[“饿汉”单例模式.png]]


这个**饿**字的体现在：**这种单例模式在以下几种情况下会直接初始化**
1. **创建该类型实例时（比如外部手动new一个对象，但是并没有使用该单例）**
2. **访问静态成员时** **（比如访问其他静态内容，但是并没有使用该单例）**
3. **使用反射获取该类型时**
4. **加载程序集时**

**也就是说在这些时刻无论是否使用该事例，都会直接初始化**
相当于不管我“吃不吃”，我就要创建它，先放在那，一种“饥不择食”的感觉。
虽然看起来“饿汉”没有“懒汉”那么好，但实际上，“饿汉”最大的优点就是“懒汉”的缺点，因为“饿汉”不用在实例化时考虑线程安全问题，它具有**天生的线程安全，C#会确保在多线程环境中这种静态成员的初始化只发生一次**。而“懒汉”在我们之前讲解的课程当中，大家已经感受到了，我们需要考虑多线程的并发访问问题。

在实际开发当中，我们**使用“懒汉”单例模式更多**，因为它**延迟性实例化**的特点的诱惑力更强。